########################################################################################
# Introduction
########################################################################################
# Specifies the ECJ evolutionary environment for the Simternet agent-based model
#
# ECJ is responsible for generating the individual agents, which will have parameters
# and behavior determined by the evolutionary algorithms specified in this file.
# For each generation, ECJ creates a Simternet, adds the agents it has created to it,
# and allows Simternet to run.  Once the agent simulation has been completed, ECJ
# takes fitness information, based on the Simternet results, which it uses to create
# the next generation of agents.  This process repeats.


########################################################################################
# Global, High-level Configuration

#verbosity	= 0

breedthreads	= 4
evalthreads	= 1
seed.0		= 4357
seed.1		= 4358
seed.2		= 4359
seed.3		= 4360
seed.4		= 4361
seed.5		= 4362
seed.6		= 4363
seed.7		= 4364
seed.8		= 4365
seed.9		= 4366
seed.10		= 4367
seed.11		= 4368
seed.12		= 4369
seed.13		= 4370
seed.14		= 4371
seed.15		= 4372
seed.16		= 4373
seed.17		= 4374
seed.18		= 4375
seed.19		= 4376
seed.20		= 4377
seed.21		= 4378
seed.22		= 4379
seed.23		= 4380
seed.24		= 4381
seed.25		= 4382
seed.26		= 4383
seed.27		= 4384
seed.28		= 4385
seed.29		= 4386
seed.30		= 4387
seed.31		= 4388

state		= ec.simple.SimpleEvolutionState
pop			= ec.Population
init		= ec.gp.GPInitializer
finish		= ec.simple.SimpleFinisher
breed		= ec.simple.SimpleBreeder
eval		= simternet.ecj.SimternetEvaluator
stat		= ec.simple.SimpleStatistics
exch		= ec.simple.SimpleExchanger

### KEY CONFIG, Specifies the Simternet Problem
# This is the class that will be evaluating our agents/individuals.
eval.problem		= simternet.ecj.problems.SimternetProblem
eval.problem.data = ec.app.tutorial4.DoubleData


quit-on-run-complete	= true
checkpoint		= true
prefix			= data/checkpoints/ecj/generation
checkpoint-modulo	= 40

stat.file		= $out.stat

pop.subpops		= 2
pop.subpop.0		= ec.Subpopulation
pop.subpop.1		= ec.Subpopulation

########################################################################################
# Simternet Evaluation Configuration
########################################################################################
# Controls how the agents are placed within the simulation, and how the simulations are run.

# How many different simulations to split the agents up into.  Each population will be divided
# into this many segments, each of which is evaluated against each other.
simternet.chunks = 10

# The number of concurrent simulation runs.  Cannot effectively be larger than the
# number of population chunks, since each chunk must be evaluated sequentially.
simternet.threads = 10

# Simternet checkpointing.  As opposed to ECJ checkpointing, which will store individuals,
# this creates checkpoints of Simternet simulations immediately after creation, so that
# we can load them and inspect how a particular simulation instance proceeded.
simternet.checkpoint = true
simternet.checkpoint-modulo = 1
simternet.checkpoint.directory = data/checkpoints/simternet/

# How many steps to run Simternet
simternet.steps = 50

########################################################################################
# Network Service Provider Configuration
########################################################################################
## Define SubPopulation #0, for Network Service Providers
# General information
pop.subpop.0.size 		= 50
pop.subpop.0.duplicate-retries 	= 100

# Charactaristics of the Species' genome/representation
pop.subpop.0.species 		= ec.gp.GPSpecies
pop.subpop.0.species.ind	= simternet.ecj.SimternetGPIndividual
pop.subpop.0.species.agent	= simternet.agents.nsp.GPNetworkProvider

# How the fitness is evaluated
pop.subpop.0.species.fitness 	= ec.simple.SimpleFitness

# The EA pipeline for new NSP individuals.
# Parameters taken from koza.params
pop.subpop.0.species.pipe = ec.breed.MultiBreedingPipeline
pop.subpop.0.species.pipe.generate-max = false
# Subsidiary pipelines:
pop.subpop.0.species.pipe.num-sources = 3
pop.subpop.0.species.pipe.source.0 = ec.gp.koza.CrossoverPipeline
pop.subpop.0.species.pipe.source.0.prob = 0.2
pop.subpop.0.species.pipe.source.1 = ec.breed.ReproductionPipeline
pop.subpop.0.species.pipe.source.1.prob = 0.7
pop.subpop.0.species.pipe.source.1.source.0 = ec.select.TournamentSelection
pop.subpop.0.species.pipe.source.2 = ec.gp.breed.MutateOneNodePipeline
pop.subpop.0.species.pipe.source.2.prob = 0.1
pop.subpop.0.species.pipe.source.2.source.0 = ec.select.TournamentSelection
pop.subpop.0.species.pipe.source.2.ns.0 = ec.gp.koza.KozaNodeSelector


########################################################################################
# NSP Function Sets and Tree Constraints - defines the allowable structure & content 
# of the NSP's GPs
########################################################################################
# when adding something, remember to update gp.fs.size and gp.tc.size, and 
# pop.subpop.0.species.ind.numtrees

# Trees
pop.subpop.0.species.ind.numtrees = 4
pop.subpop.0.species.ind.tree.0 = ec.gp.GPTree
pop.subpop.0.species.ind.tree.0.tc = priceEdgeNetworkTC
pop.subpop.0.species.ind.tree.1 = ec.gp.GPTree
pop.subpop.0.species.ind.tree.1.tc = scorePotentialNetworkTC
pop.subpop.0.species.ind.tree.2 = ec.gp.GPTree
pop.subpop.0.species.ind.tree.2.tc = priceASPTransitTC
pop.subpop.0.species.ind.tree.3 = ec.gp.GPTree
pop.subpop.0.species.ind.tree.3.tc = edgeBackboneUpgradeTC

########################################################################################
# Application Service Provider Configuration
########################################################################################
## Define SubPopulation #0, for Network Service Providers
# General information
pop.subpop.1.size 		= 200
pop.subpop.1.duplicate-retries 	= 100

# Charactaristics of the Species' genome/representation
pop.subpop.1.species 		= ec.gp.GPSpecies
pop.subpop.1.species.ind	= simternet.ecj.SimternetGPIndividual
pop.subpop.1.species.agent	= simternet.agents.asp.GPApplicationProvider

# How the fitness is evaluated
pop.subpop.1.species.fitness 	= ec.simple.SimpleFitness

# The EA pipeline for new ASP individuals.
# Parameters taken from koza.params
pop.subpop.1.species.pipe = ec.breed.MultiBreedingPipeline
pop.subpop.1.species.pipe.generate-max = false
# Subsidiary pipelines:
pop.subpop.1.species.pipe.num-sources = 3
pop.subpop.1.species.pipe.source.0 = ec.gp.koza.CrossoverPipeline
pop.subpop.1.species.pipe.source.0.prob = 0.2
pop.subpop.1.species.pipe.source.1 = ec.breed.ReproductionPipeline
pop.subpop.1.species.pipe.source.1.prob = 0.7
pop.subpop.1.species.pipe.source.1.source.0 = ec.select.TournamentSelection
pop.subpop.1.species.pipe.source.2 = ec.gp.breed.MutateOneNodePipeline
pop.subpop.1.species.pipe.source.2.prob = 0.1
pop.subpop.1.species.pipe.source.2.source.0 = ec.select.TournamentSelection
pop.subpop.1.species.pipe.source.2.ns.0 = ec.gp.koza.KozaNodeSelector

########################################################################################
# ASP Function Sets and Tree Constraints - defines the allowable structure & content 
# of the ASP's GPs
########################################################################################
# when adding something, remember to update gp.fs.size and gp.tc.size, and 
# pop.subpop.0.species.ind.numtrees

# Trees
pop.subpop.1.species.ind.numtrees = 3

pop.subpop.1.species.ind.tree.0 = ec.gp.GPTree
pop.subpop.1.species.ind.tree.0.tc = qualityInvestmentTC

pop.subpop.1.species.ind.tree.1 = ec.gp.GPTree
pop.subpop.1.species.ind.tree.1.tc = aspTransitPurchaseTC

pop.subpop.1.species.ind.tree.2 = ec.gp.GPTree
pop.subpop.1.species.ind.tree.2.tc = aspIncreaseBandwidthTC


###############################################################
# General GP configuration, used by ECJ's GP Engine
# Tree Constraints

gp.tc.size = 7

gp.tc.0 = ec.gp.GPTreeConstraints
gp.tc.0.init = ec.gp.koza.HalfBuilder
gp.tc.0.name = priceEdgeNetworkTC
gp.tc.0.fset = priceEdgeNetworkFS
gp.tc.0.returns = double

gp.tc.1 = ec.gp.GPTreeConstraints
gp.tc.1.init = ec.gp.koza.HalfBuilder
gp.tc.1.name = scorePotentialNetworkTC
gp.tc.1.fset = scorePotentialNetworkFS
gp.tc.1.returns = double

gp.tc.2 = ec.gp.GPTreeConstraints
gp.tc.2.init = ec.gp.koza.HalfBuilder
gp.tc.2.name = qualityInvestmentTC
gp.tc.2.fset = qualityInvestmentFS
gp.tc.2.returns = double

gp.tc.3 = ec.gp.GPTreeConstraints
gp.tc.3.init = ec.gp.koza.HalfBuilder
gp.tc.3.name = priceASPTransitTC
gp.tc.3.fset = priceASPTransitFS
gp.tc.3.returns = double

gp.tc.4 = ec.gp.GPTreeConstraints
gp.tc.4.init = ec.gp.koza.HalfBuilder
gp.tc.4.name = aspTransitPurchaseTC
gp.tc.4.fset = aspTransitPurchaseFS
gp.tc.4.returns = double

gp.tc.5 = ec.gp.GPTreeConstraints
gp.tc.5.init = ec.gp.koza.HalfBuilder
gp.tc.5.name = aspIncreaseBandwidthTC
gp.tc.5.fset = aspIncreaseBandwidthFS
gp.tc.5.returns = double

gp.tc.6 =  ec.gp.GPTreeConstraints
gp.tc.6.init = ec.gp.koza.HalfBuilder
gp.tc.6.name = edgeBackboneUpgradeTC
gp.tc.6.fset = edgeBackboneUpgradeFS
gp.tc.6.returns = double


# Sets of allowable functions
gp.fs.size = 18

gp.fs.0 = ec.gp.GPFunctionSet
gp.fs.0.size = 4
gp.fs.0.name = booleans
gp.fs.0.func.0 = simternet.ecj.operators.AndGP
gp.fs.0.func.0.nc = booleanOperator
gp.fs.0.func.1 = simternet.ecj.operators.NotGP
gp.fs.0.func.1.nc = booleanOperator
gp.fs.0.func.2 = simternet.ecj.operators.OrGP
gp.fs.0.func.2.nc = booleanOperator
gp.fs.0.func.3 = simternet.ecj.operators.XOrGP
gp.fs.0.func.3.nc = booleanOperator
#gp.fs.0.func.0 = simternet.ecj.terminals.TrueGP
#gp.fs.0.func.0.nc = boolean
#gp.fs.0.func.1 = simternet.ecj.terminals.FalseGP
#gp.fs.0.func.1.nc = boolean


gp.fs.1 = ec.gp.GPFunctionSet
gp.fs.1.size = 10
gp.fs.1.name = doubles
gp.fs.1.func.0 = simternet.ecj.operators.AddGP
gp.fs.1.func.0.nc = doubleOperatorSimple
gp.fs.1.func.1 = simternet.ecj.operators.SubtractGP
gp.fs.1.func.1.nc = doubleOperatorSimple
gp.fs.1.func.2 = simternet.ecj.operators.MultiplyGP
gp.fs.1.func.2.nc = doubleOperatorSimple
gp.fs.1.func.3 = simternet.ecj.operators.DivideGP
gp.fs.1.func.3.nc = doubleOperatorSimple
# an if statement, one tree if true, another if false.
gp.fs.1.func.4 = simternet.ecj.operators.DoubleSelector
gp.fs.1.func.4.nc = decisionDouble
gp.fs.1.func.5 = simternet.ecj.operators.GreaterThanGP
gp.fs.1.func.5.nc = compareNumber
gp.fs.1.func.6 = simternet.ecj.operators.LessThanGP
gp.fs.1.func.6.nc = compareNumber
gp.fs.1.func.7 = simternet.ecj.terminals.Seven
gp.fs.1.func.7.nc = double
gp.fs.1.func.8 = simternet.ecj.terminals.Five
gp.fs.1.func.8.nc = double
# Random, evolvable constant between 0 and 1.  Set once, unless ECJ decides
# to mutate this node, at which point it changes.
gp.fs.1.func.9 = simternet.ecj.terminals.RandomRatioGP
gp.fs.1.func.9.nc = double

gp.fs.2 = ec.gp.GPFunctionSet
gp.fs.2.size = 1
gp.fs.2.name = edgeNetwork
gp.fs.2.func.0 = simternet.ecj.terminals.NumEdgeSubscribers
gp.fs.2.func.0.nc = double

gp.fs.3 = simternet.ecj.GPFunctionSetSet
gp.fs.3.size = 5
gp.fs.3.name = priceEdgeNetworkFS
gp.fs.3.funcSet.0 = gp.fs.0
gp.fs.3.funcSet.1 = gp.fs.1
gp.fs.3.funcSet.2 = gp.fs.2
gp.fs.3.funcSet.3 = gp.fs.6
gp.fs.3.funcSet.4 = gp.fs.8

gp.fs.4 = ec.gp.GPFunctionSet
gp.fs.4.size = 4
gp.fs.4.name = potentialNetwork
# cost of building the network
gp.fs.4.func.0 = simternet.ecj.terminals.PotentialNetworkCost
gp.fs.4.func.0.nc = double
gp.fs.4.func.1 = simternet.ecj.terminals.PotentialNetworkDistanceFromHome
gp.fs.4.func.1.nc = double
gp.fs.4.func.2 = simternet.ecj.terminals.PotentialNetworkNumCompetitors
gp.fs.4.func.2.nc = double
gp.fs.4.func.3 = simternet.ecj.terminals.PotentialNetworkPopulation
gp.fs.4.func.3.nc = double

gp.fs.5 = simternet.ecj.GPFunctionSetSet
gp.fs.5.size = 4
gp.fs.5.name = scorePotentialNetworkFS
gp.fs.5.funcSet.0 = gp.fs.0
gp.fs.5.funcSet.1 = gp.fs.1
gp.fs.5.funcSet.2 = gp.fs.4
gp.fs.5.funcSet.3 = gp.fs.6

gp.fs.6 = ec.gp.GPFunctionSet
gp.fs.6.size = 16
gp.fs.6.name = financials
gp.fs.6.func.0 = simternet.ecj.terminals.AssetsCapital
gp.fs.6.func.0.nc = double
gp.fs.6.func.1 = simternet.ecj.terminals.AssetsLiquid
gp.fs.6.func.1.nc = double
gp.fs.6.func.2 = simternet.ecj.terminals.DebtBalance
gp.fs.6.func.2.nc = double
gp.fs.6.func.3 = simternet.ecj.terminals.DebtInterestRate
gp.fs.6.func.3.nc = double
gp.fs.6.func.4 = simternet.ecj.terminals.DebtPayoffRate
gp.fs.6.func.4.nc = double
gp.fs.6.func.5 = simternet.ecj.terminals.DepreciationRate
gp.fs.6.func.5.nc = double
gp.fs.6.func.6 = simternet.ecj.terminals.PerStepFinancingCost
gp.fs.6.func.6.nc = double
gp.fs.6.func.7 = simternet.ecj.terminals.PerStepInvestment
gp.fs.6.func.7.nc = double
gp.fs.6.func.8 = simternet.ecj.terminals.PerStepOperationsCost
gp.fs.6.func.8.nc = double
gp.fs.6.func.9 = simternet.ecj.terminals.TotalFinancingCost
gp.fs.6.func.9.nc = double
gp.fs.6.func.10 = simternet.ecj.terminals.TotalOperationsCost
gp.fs.6.func.10.nc = double
gp.fs.6.func.11 = simternet.ecj.terminals.TotalRevenue
gp.fs.6.func.11.nc = double
gp.fs.6.func.12 = simternet.ecj.terminals.DeltaRevenue
gp.fs.6.func.12.nc = double
gp.fs.6.func.13 = simternet.ecj.terminals.IncreasingRevenue
gp.fs.6.func.13.nc = boolean
gp.fs.6.func.14 = simternet.ecj.terminals.NetWorth
gp.fs.6.func.14.nc = double
gp.fs.6.func.15 = simternet.ecj.terminals.PresentValue
gp.fs.6.func.15.nc = double

gp.fs.7 = simternet.ecj.GPFunctionSetSet
gp.fs.7.size = 3
gp.fs.7.name = qualityInvestmentFS
gp.fs.7.funcSet.0 = gp.fs.0
gp.fs.7.funcSet.1 = gp.fs.1
gp.fs.7.funcSet.2 = gp.fs.6

gp.fs.8 = ec.gp.GPFunctionSet
gp.fs.8.size = 3
gp.fs.8.name = edgePricingInfoFS
gp.fs.8.func.0 = simternet.ecj.terminals.NumEdgeNetworks
gp.fs.8.func.0.nc = double
gp.fs.8.func.1 = simternet.ecj.terminals.LowestEdgePrice
gp.fs.8.func.1.nc = double
gp.fs.8.func.2 = simternet.ecj.terminals.LowestOtherEdgePrice
gp.fs.8.func.2.nc = double

gp.fs.9 = simternet.ecj.GPFunctionSetSet
gp.fs.9.size = 5
gp.fs.9.name = priceASPTransitFS
gp.fs.9.funcSet.0 = gp.fs.0
gp.fs.9.funcSet.1 = gp.fs.1
gp.fs.9.funcSet.2 = gp.fs.6
gp.fs.9.funcSet.3 = gp.fs.10
gp.fs.9.funcSet.4 = gp.fs.15

gp.fs.10 = ec.gp.GPFunctionSet
gp.fs.10.size = 2
gp.fs.10.name = aspInfo
gp.fs.10.func.0 = simternet.ecj.terminals.NumASPCustomers
gp.fs.10.func.0.nc = double
gp.fs.10.func.1 = simternet.ecj.terminals.ASPNumConnectedNSPs
gp.fs.10.func.1.nc = double

gp.fs.11 = ec.gp.GPFunctionSet
gp.fs.11.size = 1
gp.fs.11.name = nspInfo
gp.fs.11.func.0 = simternet.ecj.terminals.NumNSPCustomers
gp.fs.11.func.0.nc = double

gp.fs.12 = simternet.ecj.GPFunctionSetSet
gp.fs.12.size = 5
gp.fs.12.name = aspTransitPurchaseFS
gp.fs.12.funcSet.0 = gp.fs.0
gp.fs.12.funcSet.1 = gp.fs.1
gp.fs.12.funcSet.2 = gp.fs.6
gp.fs.12.funcSet.3 = gp.fs.10
#gp.fs.12.funcSet.4 = gp.fs.15
gp.fs.12.funcSet.4 = gp.fs.16

gp.fs.13 = ec.gp.GPFunctionSet
gp.fs.13.size = 1
gp.fs.13.name = backboneLinkInfo
gp.fs.13.func.0 = simternet.ecj.terminals.NumNSPCustomers
gp.fs.13.func.0.nc = double

gp.fs.14 = simternet.ecj.GPFunctionSetSet
gp.fs.14.size = 4
gp.fs.14.name = aspIncreaseBandwidthFS
gp.fs.14.funcSet.0 = gp.fs.0
gp.fs.14.funcSet.1 = gp.fs.1
gp.fs.14.funcSet.2 = gp.fs.6
gp.fs.14.funcSet.3 = gp.fs.10

gp.fs.15 = ec.gp.GPFunctionSet
gp.fs.15.size = 2
gp.fs.15.name = backboneLinkFS
gp.fs.15.func.0 = simternet.ecj.terminals.BackboneBandwidth
gp.fs.15.func.0.nc = double
gp.fs.15.func.1 = simternet.ecj.terminals.BackboneCongestionRatio
gp.fs.15.func.1.nc = double

gp.fs.16 = ec.gp.GPFunctionSet
gp.fs.16.size = 1
gp.fs.16.name = simplePriceFS
gp.fs.16.func.0 = simternet.ecj.terminals.Price
gp.fs.16.func.0.nc = double

gp.fs.17 = simternet.ecj.GPFunctionSetSet
gp.fs.17.name = edgeBackboneUpgradeFS
gp.fs.17.size = 5
# standard double GPNodes
gp.fs.17.funcSet.0 = gp.fs.0
# standard boolean GPNodes
gp.fs.17.funcSet.1 = gp.fs.1
# financials
gp.fs.17.funcSet.2 = gp.fs.6
# general info for that location
gp.fs.17.funcSet.3 = gp.fs.8 
# info on the specific backbone in question
gp.fs.17.funcSet.4 = gp.fs.15


########################################################################################
# General GP reproduction defaults, taken from ECJ's koza.params
########################################################################################
# Here we define the default values for Crossover,
# Reproduction, Mutation, as well as our selection
# approaches (Koza I).  These can be overridden on a per-species
# level of course.
#

# Reproduction will use Tournament Selection 
breed.reproduce.source.0 = ec.select.TournamentSelection

# Crossover will use Tournament Selection, try only 1
# time, have a max depth of 17, and use KozaNodeSelector
gp.koza.xover.source.0 = ec.select.TournamentSelection
gp.koza.xover.source.1 = same
gp.koza.xover.ns.0 = ec.gp.koza.KozaNodeSelector
gp.koza.xover.ns.1 = same
gp.koza.xover.maxdepth = 10

# This is the default for Koza and lil-gp, though it's
# a little wimpy; on the other hand, a higher number can
# make things really slow
gp.koza.xover.tries = 1

# Point Mutation will use Tournament Selection, try only 1
# time, have a max depth of 17, and use KozaNodeSelector
# and GROW for building.  Also, Point Mutation uses a GrowBuilder
# by default, with a default of min-depth=max-depth=5
# as shown a ways below
gp.koza.mutate.source.0 = ec.select.TournamentSelection
gp.koza.mutate.ns.0 = ec.gp.koza.KozaNodeSelector
gp.koza.mutate.build.0 = ec.gp.koza.GrowBuilder
gp.koza.mutate.maxdepth = 10
# This is the default for Koza and lil-gp, though it's
# a little wimpy; on the other hand, a higher number can
# make things really slow
gp.koza.mutate.tries = 1

# The default tournament size for TournamentSelection is 7
# kk - try 2, more likely to get diversity?
select.tournament.size = 2

gp.koza.half.min-depth = 2
gp.koza.half.max-depth = 6
gp.koza.half.growp = 0.5

# Since GROW is only used for subtree mutation, ECJ uses
# the Koza-standard subtree mutation GROW values for the
# default for GROW as a whole.  This default is
# min-depth=max-depth=5, which I don't like very much,
# but hey, that's the standard.  
# This means that if someone decided to use GROW to generate
# new individual trees, it's also use the defaults below
# unless he overrided them locally.
gp.koza.grow.min-depth = 5
gp.koza.grow.max-depth = 5

# We specify a few things about ADFs  -- what kind 
# of stack they use, and what kind of context
gp.problem.stack = ec.gp.ADFStack
gp.adf-stack.context = ec.gp.ADFContext

# Here we define the default values for KozaNodeSelection;
# as always, these can be overridden by values hanging off
# of the Crossover/Reproduction/Mutation/whatever pipelines,
# like we did for node-building, but hey, whatever. 
# The default is 10% terminals, 90% nonterminals when possible,
# 0% "always pick the root", 0% "pick any node"
gp.koza.ns.terminals = 0.1
gp.koza.ns.nonterminals = 0.85
gp.koza.ns.root = 0.05

gp.nc.size = 6

gp.nc.0 = ec.gp.GPNodeConstraints
gp.nc.0.name = double
gp.nc.0.returns = double
gp.nc.0.size = 0

gp.nc.1 = ec.gp.GPNodeConstraints
gp.nc.1.name = boolean
gp.nc.1.returns = boolean
gp.nc.1.size = 0

gp.nc.2 = ec.gp.GPNodeConstraints
gp.nc.2.name = doubleOperatorSimple
gp.nc.2.returns = double
gp.nc.2.size = 2
gp.nc.2.child.0 = double
gp.nc.2.child.1 = double

gp.nc.3 = ec.gp.GPNodeConstraints
gp.nc.3.name = decisionDouble
gp.nc.3.returns = double
gp.nc.3.size = 3
gp.nc.3.child.0 = boolean
gp.nc.3.child.1 = double
gp.nc.3.child.2 = double

gp.nc.4 = ec.gp.GPNodeConstraints
gp.nc.4.name = compareNumber
gp.nc.4.returns = boolean
gp.nc.4.size = 2
gp.nc.4.child.0 = number
gp.nc.4.child.1 = number

gp.nc.5 = ec.gp.GPNodeConstraints
gp.nc.5.name = booleanOperator
gp.nc.5.size = 2
gp.nc.5.returns = boolean
gp.nc.5.child.0 = boolean
gp.nc.5.child.1 = boolean


########################################################################################
# General GP representation defaults, taken from ECJ's koza.params (types, etc...)
########################################################################################
#types
gp.type.a.size = 3
gp.type.a.0.name = double
gp.type.a.1.name = boolean
gp.type.a.2.name = integer
gp.type.s.size = 1
gp.type.s.0.name = number
gp.type.s.0.size = 1
gp.type.s.0.member.0 = double

